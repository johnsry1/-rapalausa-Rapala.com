/**
* 	Builds a structure that represents the slot configurations in the file system 
*/
importPackage( dw.system );
importPackage( dw.catalog );
importPackage( dw.io );

var cvLogger = Logger.getLogger( 'SaveSlotsInFileSystem' );


function execute( pdict : PipelineDictionary ) : Number
{
	
	// sourcefile is generated by a step beforehand, it is a demandware content slot export of any site 
	var sourceFile : File = new File(File.IMPEX + File.SEPARATOR + "src" + File.SEPARATOR + 'temp' + File.SEPARATOR + 'temp_slot_export.xml');
	var startFolder : File = new File(File.IMPEX + File.SEPARATOR + "contentcopy" + File.SEPARATOR + "slots" + File.SEPARATOR + "structure" + File.SEPARATOR + dw.system.Site.getCurrent().ID);
	
	var sizeStorage : File = new File(File.IMPEX + File.SEPARATOR + "contentcopy" + File.SEPARATOR + "slots" + File.SEPARATOR + "structure" + File.SEPARATOR +  "lastRunSize_" + dw.system.Site.getCurrent().ID + ".txt");
	
	// we assume that nothing has changed, when the file size of the previous run and this is the same
	// causes less noise on the filesystem over night or on weekends
	if (sizeStorage.exists()) {
		var sizeStorageReader = new FileReader(sizeStorage);
		var lastRunFileSize = "";
		// assume files to be small enough to be consumed at once, as they were written with one string
		try {
			lastRunFileSize = sizeStorageReader.getString();
			sizeStorageReader.close();

		} catch (e) {
			Logger.warn("SaveSlotsIntoFileSystem: Delta check failed");	
		}
		if (!empty(lastRunFileSize) && lastRunFileSize == sourceFile.length()) {
			return PIPELET_NEXT;	
		} else {
			// remove for now, to catch servr restarts etc.
			sizeStorage.remove();
		}
	}		
	
	var fileSystemCache : dw.util.HashMap = new dw.util.HashMap(); 
	var elementsInExport : dw.util.HashSet = new dw.util.HashSet(); 
	fileSystemCache = buildFileIndex(startFolder, fileSystemCache);
	
	// initialise the file readers
	var reader : FileReader = new FileReader(sourceFile, 'UTF-8');
	var xmlreader : XMLStreamReader = new XMLStreamReader(reader);
	// traverse through the XML file
	var availableLocales = new dw.util.HashSet();
	while (xmlreader.hasNext()) {
		var event = xmlreader.next();
		// if we have a new slot configuration
		if (event == XMLStreamConstants.START_ELEMENT && xmlreader.localName == 'slot-configuration') {
	
			var xmlObject : XML = xmlreader.getXMLObject();
			var context = xmlObject.attribute('context');
			var configurationID = xmlObject.attribute('configuration-id').toString();  
			configurationID = configurationID.replace(/[^a-zA-Z0-9]/g,'_');
			var slotID = xmlObject.attribute('slot-id');  
			
			// used for cleanup
			elementsInExport.add1(configurationID);
			
			/** Delta processing */
			var startTimeStamp = (new Date()).getTime();
			
			// get files for current config ID
			var filesRepresentingElement : dw.util.ArrayList = new dw.util.ArrayList(); 
			var cachedEntry = fileSystemCache.get(configurationID);
			
			var writeSlotConfig = true;

			var xmlToWrite : String = xmlObject.toString();
			var existingFileContent : String = "";
			
			/** Check if we have an existing file for this config and if so, check if we need to write it again. */
			/** IO Read is much faster then IO write */
			if (!empty(cachedEntry)) {
				// we do have a file representing the current element
				filesRepresentingElement.addAll(cachedEntry);
				// compare content of the element in filesystem and in the XML
				// first element is fine, as the content is the same accross all locale files
				var fileToCheck : File = filesRepresentingElement.get(0);
				
				if (fileToCheck.exists()) {
					var xmlLength = xmlToWrite.length;
					var fileLength = fileToCheck.length();
					if (xmlLength == fileLength) {
						var deltaCheckReader = new FileReader(fileToCheck);
						// assume files to be small enough to be consumed at once, as they were written with one string
						try {
							existingFileContent = deltaCheckReader.getString();
						} catch (e) {
							Logger.warn("SaveSlotsIntoFileSystem: Delta check failed");	
						}
						
						// if contents are equal, we don't have to write the file and crawl through the category tree		
						if (existingFileContent == xmlToWrite) {
							writeSlotConfig = false;
							// touch all referenced files to mark them as found, and not deletable					
								
						}
					}
				}				
			}					
				
			
			if (writeSlotConfig) {
				// write slot snippet into corresponding file
				var categoryPath : String = "_global_";
				try {
					// if we have a category slot, put it in a category specific folder
					if (context == "category") {
						var categoryID = xmlObject.attribute('context-id');  
						var category : Category = dw.catalog.CatalogMgr.getCategory(categoryID);
						// generate file path by traversing up the category tree
						if (!empty(category)) {
							// reset categoryPath variable, which was assumed global in the beginning
							categoryPath = "";
							var loopCategory : Category = category; 
							while (loopCategory.ID != 'root') {
								categoryPath = loopCategory.ID + File.SEPARATOR + categoryPath ;
								loopCategory = loopCategory.getParent();
							}
						}
					} 
					
					var xml = new Namespace("xml", "http://www.w3.org/XML/1998/namespace");
					
					availableLocales.add('x-default');
					for each (var xmlElement in xmlObject.descendants()) {
						for each(var xmlLang in (xmlElement.@xml::lang)){
							availableLocales.add(xmlLang.toString());
						}
					}
					var folderToWrite : File = new File(startFolder.getFullPath() + File.SEPARATOR + categoryPath + File.SEPARATOR + "_slot-" + slotID);
					if (!folderToWrite.exists()) {
						folderToWrite.mkdirs();
					} 	
					
					var xmlToWrite : String = xmlObject.toString();
					
					for each (var availableLocale in availableLocales) {
						var fileToWrite : File = new File(folderToWrite.getFullPath() + File.SEPARATOR + configurationID + "_" + availableLocale + ".slot");
						if (!fileToWrite.exists()) {
							fileToWrite.createNewFile();
						} 	
										
						var fileWriter : FileWriter = new FileWriter(fileToWrite, 'UTF-8' ,false);
						fileWriter.write(xmlToWrite);
						fileWriter.close();
					}
					availableLocales.clear();
				} catch (e) {
					cvLogger.error("Exeception while processing slot element: " + e);
				}				
			}
		} 
	}
	
	sizeStorage.createNewFile();
	
	var sizeWriter : FileWriter = new FileWriter(sizeStorage, "UTF-8", false);
	sizeWriter.write(sourceFile.length());
	sizeWriter.close();
	
	xmlreader.close();
	reader.close();
	
	// clean up elements not in export, by first removing touched object from file system cache
	for each (var elementInExport : String in elementsInExport) {
		fileSystemCache.remove(elementInExport);
	}
	// and second delete whats left over
	var leftOverElements = fileSystemCache.keySet();
	for each (var leftOverElement : String in leftOverElements) {
		var referencedFiles : dw.util.HashSet = fileSystemCache.get(leftOverElement);
		for each (var referencedFile : File in referencedFiles) {
			referencedFile.remove();
		} 
	}
	
		
	sourceFile.remove();
		
    return PIPELET_NEXT;
}


/**
*	Crawls file structure and puts its contents file into Hashmap configID - folder
*/
function buildFileIndex (currentDir : File, fileSystemCache : dw.util.HashMap) {
	var fileNames : Array = currentDir.list();
	for each (var fileName : String in fileNames){
		var filePath : String = currentDir.getFullPath() + File.SEPARATOR + fileName;
		var candidate : File = new File(filePath);
		
		if (candidate.isDirectory()){
			fileSystemCache = buildFileIndex(candidate, fileSystemCache);
		} else {
			var elementID = candidate.getName().substring(0, candidate.getName().lastIndexOf("_"));
			var subSet : dw.util.HashSet = fileSystemCache.get(elementID);
			if (empty(subSet)) {
				subSet = new dw.util.HashSet();
			}
			subSet.add1(candidate);
			fileSystemCache.put(elementID, subSet);

		}
	}	
	return fileSystemCache;
}