/**
* Builds a structure that represents the assets in the file system 
*
*/
importPackage( dw.system );
importPackage( dw.content );
importPackage( dw.io );

var cvLogger = Logger.getLogger( 'SaveAssetsInFileSystem' );

function execute( pdict : PipelineDictionary ) : Number
{
	
	// sourcefile is generated by a step beforehand, it is a demandware library export of any site 
	var sourceFile : File = new File(File.IMPEX + File.SEPARATOR + "src" + File.SEPARATOR + 'temp' + File.SEPARATOR + 'temp_asset_export.xml');
	var startFolder : File = new File(File.IMPEX + File.SEPARATOR + "contentcopy" + File.SEPARATOR + "content" + File.SEPARATOR + "structure" + File.SEPARATOR + dw.system.Site.getCurrent().ID);

	var sizeStorage : File = new File(File.IMPEX + File.SEPARATOR + "contentcopy" + File.SEPARATOR + "content" + File.SEPARATOR + "structure" + File.SEPARATOR +  "lastRunSize_" + dw.system.Site.getCurrent().ID + ".txt");
	
	// we assume that nothing has changed, when the file size of the previous run and this is the same
	// causes less noise on the filesystem over night or on weekends
	if (sizeStorage.exists()) {
		var sizeStorageReader = new FileReader(sizeStorage);
		var lastRunFileSize = "";
		// assume files to be small enough to be consumed at once, as they were written with one string
		try {
			lastRunFileSize = sizeStorageReader.getString();
			sizeStorageReader.close();

		} catch (e) {
			Logger.warn("SaveAssetsIntoFileSystem: Delta check failed");	
		}
		if (!empty(lastRunFileSize) && lastRunFileSize == sourceFile.length()) {
			return PIPELET_NEXT;	
		} else {
			// remove for now, to catch servr restarts etc.
			sizeStorage.remove();
		}
	}		
	
	var fileSystemCache : dw.util.HashMap = new dw.util.HashMap(); 
	var elementsInExport : dw.util.HashSet = new dw.util.HashSet(); 
	fileSystemCache = buildFileIndex(startFolder, fileSystemCache);
	
	// initialise the file readers
	var reader : FileReader = new FileReader(sourceFile, 'UTF-8');
	var xmlreader : XMLStreamReader = new XMLStreamReader(reader);
	// traverse through the XML file
	var availableLocales = new dw.util.HashSet();
	while (xmlreader.hasNext()) {
		var event = xmlreader.next();
		// if we have a new contentasset
		if (event == XMLStreamConstants.START_ELEMENT && xmlreader.localName == 'content') {
	
			var xmlObject : XML = xmlreader.getXMLObject();
			var assetID = xmlObject.attribute('content-id').toString();
			
			/** Delta processing */
			var startTimeStamp = (new Date()).getTime();
			
			// get files for current config ID
			var filesRepresentingElement : dw.util.ArrayList = new dw.util.ArrayList(); 
			var cachedEntry = fileSystemCache.get(assetID);
			// used for cleanup
			elementsInExport.add1(assetID.replace(/[^a-zA-Z0-9]/g,'_'));
			var writeSlotConfig = true;

			var xmlToWrite : String = xmlObject.toString();
			var existingFileContent : String = "";
			
			/** Check if we have an existing file for this config and if so, check if we need to write it again. */
			/** IO Read is much faster then IO write */
			if (!empty(cachedEntry)) {
				// we do have a file representing the current element
				filesRepresentingElement.addAll(cachedEntry);
				// compare content of the element in filesystem and in the XML
				// first element is fine, as the content is the same accross all locale files
				var fileToCheck : File = filesRepresentingElement.get(0);
				
				if (fileToCheck.exists()) {
					var xmlLength = xmlToWrite.length;
					var fileLength = fileToCheck.length();
					
					// do not bother to check in case the sizes are different, we have a delta
					if (xmlLength == fileLength) {
						var deltaCheckReader = new FileReader(fileToCheck);
						// assume files to be small enough to be consumed at once, as they were written with one string
						try {
							existingFileContent = deltaCheckReader.getString();
						} catch (e) {
							Logger.warn("SaveSlotsIntoFileSystem: Delta check failed");	
						}
						
						// if contents are equal, we don't have to write the file and crawl through the category tree		
						if (existingFileContent == xmlToWrite) {
							writeSlotConfig = false;
							// touch all referenced files to mark them as found, and not deletable					
								
						}
					}
				}				
			}					
				
			
			if (writeSlotConfig && !empty(ContentMgr.getContent(assetID))) {
				var asset = ContentMgr.getContent(assetID);
				try {
				// write slot snippet into corresponding file
					// if we have a category slot, put it in a category specific folder
					var xml = new Namespace("xml", "http://www.w3.org/XML/1998/namespace");
					
					availableLocales.add('x-default');
					for each (var xmlElement in xmlObject.descendants()) {
						for each(var xmlLang in (xmlElement.@xml::lang)){
							availableLocales.add(xmlLang.toString());
						}
					}
					
					// assume folder to be unassigned
					var subPath : String = "_unassigned_";
					// get the assigned classification folder
					var folder : Folder = asset.getClassificationFolder();
					// if no classification folder could be found, use first folder
					if (empty(folder) && !empty(asset.getFolders())) {
						folder = asset.getFolders().iterator().next();	
					}
					
					// build file path
					if (!empty(folder)) {
						subPath = "";
						while (folder.parent != null) {
							subPath = folder.ID.replace(/[^a-zA-Z0-9]/g,'_') + File.SEPARATOR + subPath;	
							folder = folder.parent;
						}
					} 
					
					for each (var availableLocale in availableLocales) {
						// write xml snippet to file	
						var folderToWrite : File = new File(startFolder.getFullPath() + File.SEPARATOR + subPath);
						if (!folderToWrite.exists()) {
							folderToWrite.mkdirs();
						} 	
						
						var fileToWrite : File = new File(folderToWrite.fullPath + File.SEPARATOR + assetID.replace(/[^a-zA-Z0-9]/g,'_') + "_"+ availableLocale + ".asset" );
						if (!fileToWrite.exists()) {
							fileToWrite.createNewFile();
						} 	
											
						var fileWriter : FileWriter = new FileWriter(fileToWrite, 'UTF-8' ,false);
						fileWriter.write(xmlToWrite);
						fileWriter.close();
					}
					availableLocales.clear();
					
				} catch (e) {
					cvLogger.error("Exeception while processing asset element: " + e);
				}				
			}
		} 
	}
	
	sizeStorage.createNewFile();
	
	var sizeWriter : FileWriter = new FileWriter(sizeStorage, "UTF-8", false);
	sizeWriter.write(sourceFile.length());
	sizeWriter.close();
	
	xmlreader.close();
	reader.close();
	
	// clean up elements not in export, by first removing touched object from file system cache
	for each (var elementInExport : String in elementsInExport) {
		fileSystemCache.remove(elementInExport);
	}
	// and second delete whats left over
	var leftOverElements = fileSystemCache.keySet();
	for each (var leftOverElement : String in leftOverElements) {
		var referencedFiles : dw.util.HashSet = fileSystemCache.get(leftOverElement);
		for each (var referencedFile : File in referencedFiles) {
			referencedFile.remove();
		} 
	}
	
	sourceFile.remove();
		
    return PIPELET_NEXT;
}


/**
*	Crawls file structure and puts its contents file into Hashmap configID - folder
*/
function buildFileIndex (currentDir : File, fileSystemCache : dw.util.HashMap) {
	var fileNames : Array = currentDir.list();
	for each (var fileName : String in fileNames){
		var filePath : String = currentDir.getFullPath() + File.SEPARATOR + fileName;
		var candidate : File = new File(filePath);
		
		if (candidate.isDirectory()){
			fileSystemCache = buildFileIndex(candidate, fileSystemCache);
		} else {
			var elementID = candidate.getName().substring(0, candidate.getName().lastIndexOf("_"));
			var subSet : dw.util.HashSet = fileSystemCache.get(elementID);
			if (empty(subSet)) {
				subSet = new dw.util.HashSet();
			}
			
			subSet.add1(candidate);
			fileSystemCache.put(elementID, subSet);

		}
	}	
	return fileSystemCache;
}