// Copyright © 2013 Priority Fulfillment Services, Inc. All rights reserved.
/**
 * libOrderExportSFTP.ds
 *
 * This script gathers all the values required to build a request
 * to get an authorization from CyberSource.
 * It also deals with the response and puts the response values to the payment transaction belonging to the payment instrument.
 *
 * @input StorefrontPassword		: String
 * @input HasErrors					: Boolean
 */
/**
 * Provides common functionality for PFSweb Order Export
 */
importPackage(dw.system);
importPackage(dw.rpc);
importPackage(dw.util);
importPackage(dw.value);
importPackage(dw.order);
importPackage(dw.catalog);
importPackage(dw.campaign);
importPackage(dw.crypto);
importPackage(dw.customer);
importPackage(dw.object);
importPackage(dw.net);
importPackage(dw.io);

importScript("bc_common:lib/libOrderExportCustom.ds");
importScript("bc_common:util/ETEUtils.ds");

var storefrontPassword: String = "";
/**
 *  At the moment there are rounding issues in the web service implementation.
 *  That means a value from 8.95 is rounded to 8.949999999999999.
 *  We add a defined small amount to avoid this issues.
 */
var shouldAvoidRounding: Number = 0.00001;

function sendOrdersSFTP(pdict: PipelineDictionary, counter: Number): Object {

	var currentOrders: Iterator = pdict.CurrentOrders;
	if (!currentOrders.hasNext()) {
		return [null, null, null];
	}


	// 2011-12-06 RKB - MaxFiles, MaxOrdersPerFile from job parameter map
	var maxOrdersPerFile: Number = 100;
	var maxFiles: Number = 1;
	var multiShip: Boolean = false;

	if ('MaxOrdersPerFile' in pdict && pdict.MaxOrdersPerFile != null) {
		try {
			maxOrdersPerFile = pdict.MaxOrdersPerFile;
		} catch (exSetMaxOrders) {}
	} else {
		maxOrdersPerFile = this.getMaxExportOrderNumber();
	}

	if ('MaxFiles' in pdict && pdict.MaxFiles != null) {
		try {
			maxFiles = pdict.MaxFiles;
		} catch (exSetMaxFiles) {}
	}

	var responseCode = new HashMap();
	var successfulOrdersCumulative: Array = new Array();
	var failedOrdersCumulative: Array = new Array();

	// Create multiple files up to maxFiles
	for (var fileCounter = 0; fileCounter < maxFiles; fileCounter++) {

		if (!currentOrders.hasNext()) {
			break;
		}

		// Create order export file
		var date: Calendar = new Calendar();

		// 2011-09-20 new file naming convention to include reference to first order ID and clientID
		var isFirstOrder: Boolean = true;
		var firstOrder: Order = currentOrders.next();
		var file: File = new File(dw.io.File.IMPEX + File.SEPARATOR + "upload" + File.SEPARATOR + "DWOrder_" + Site.getCurrent().preferences.custom.jde_storeID + "_" + firstOrder.orderNo + ".xml");
		//var file : File = new File(dw.io.File.IMPEX + File.SEPARATOR + "upload" + File.SEPARATOR + "OrderExport_" + StringUtils.formatCalendar(date, "yyyyMMdd_HHmmss") + ".xml");

		if (file.exists()) {
			//sendMail("", "", "OrderExport2:SameFileNameIssue", "Needs Attention: File name already exists starting with orderno: " + firstOrder.getOrderNo() + "," + file.name);
			file = new File(dw.io.File.IMPEX + File.SEPARATOR + "upload" + File.SEPARATOR + "DWOrder_" + Site.getCurrent().preferences.custom.jde_storeID + "_" + firstOrder.orderNo + "_" + StringUtils.formatCalendar(date, "yyyyMMdd_HHmmss") + ".xml");

		}
		var fileWriter: FileWriter = new FileWriter(file, "utf-8");
		var xmlWriter: XMLIndentingStreamWriter = new XMLIndentingStreamWriter(fileWriter);

		xmlWriter.writeStartDocument("UTF-8", "1.0");
		xmlWriter.writeStartElement("Orders");

		// Add each order to the export
		var i: Number = 0;
		var successfulOrders: Array = new Array();
		var failedOrders: Array = new Array();
		var firstSuccessfulOrder: String = "";

		while ((currentOrders.hasNext() || isFirstOrder) && i < maxOrdersPerFile) {

			i++;
			var currentOrder: Order;
			if (isFirstOrder) {
				currentOrder = firstOrder;
				isFirstOrder = false;
			} else {
				currentOrder = currentOrders.next();
			}

			/*if (currentOrder.getShipments().size()>1) {
		    		multiShip = true;
			  		Logger.debug("Exporting Multi Shipment Order: " + currentOrder.getOrderNo());
		    	}*/

			Logger.debug("Exporting Order: " + currentOrder.getOrderNo());
			////Check for SDR failure and missing auth if one of shipments is missing it then skip complete order
			///////// how to handle rejection when getting re-auth
			///////
			var processOrder: Boolean = true;

			if (IsSDRMissing(currentOrder)) {
				processOrder = false;
				Logger.error("OrderExport2 mising SDR for Order: " + currentOrder.getOrderNo());
				continue;
			}

			if (IsCCAuthMissing(currentOrder)) {
				processOrder = false;
				Logger.error("OrderExport2 mising CC auth for Order: " + currentOrder.getOrderNo());
				continue;

			}
			if (IsDiscountCalculationMissing(currentOrder)) {
				processOrder = false;
				Logger.error("OrderExport2 mising discount calc for Order: " + currentOrder.getOrderNo());
				continue;
			}


			if (!processOrder) {
				dw.system.Logger.error("One or more payments for order {0} failed to generate an SDR token, cc auth or discount precalc.  These will be SKIPPED and RETRIED with the next run of order export", currentOrder.getOrderNo());
				continue;
				//before order export we will re-auth the failed cc orders and re-export and get sdr token.
			} else {

				for each(var shipment: Shipment in currentOrder.shipments) {
					// Add the <Order> node
					xmlWriter.writeStartElement("Order");

					// Order Header 
					Logger.debug("orderexport2...writing order header");
					if (!addOrderHeader(this, xmlWriter, currentOrder, shipment)) {
						failedOrders.push(currentOrder.getOrderNo());
						addXMLElement(xmlWriter, "OrderHasError", "True");
						xmlWriter.writeEndElement(); // Order
						continue;
					}

					// Order Line Items
					Logger.debug("orderexport2...writing line items");
					if (!addOrderLineItems(this, xmlWriter, currentOrder, shipment)) {
						failedOrders.push(currentOrder.getOrderNo());
						addXMLElement(xmlWriter, "OrderHasError", "True");
						xmlWriter.writeEndElement(); // Order
						continue;
					}

					// Payments
					Logger.debug("orderexport2...writing payments");
					var sdrToken;
					if (!addPayments(this, xmlWriter, currentOrder, sdrToken, shipment)) {
						failedOrders.push(currentOrder.getOrderNo());
						addXMLElement(xmlWriter, "OrderHasError", "True");
						xmlWriter.writeEndElement(); // Order
						continue;
					}
					// Shipments
					Logger.debug("orderexport2...writing shipments");
					if (!addShipment(this, xmlWriter, currentOrder, shipment)) {
						failedOrders.push(currentOrder.getOrderNo());
						addXMLElement(xmlWriter, "OrderHasError", "True");
						xmlWriter.writeEndElement(); // Order
						continue;
					}

					// Billing
					Logger.debug("orderexport2...writing billing");
					if (!addBilling(this, xmlWriter, currentOrder, shipment)) {
						failedOrders.push(currentOrder.getOrderNo());
						addXMLElement(xmlWriter, "OrderHasError", "True");
						xmlWriter.writeEndElement(); // Order
						continue;
					}

					xmlWriter.writeEndElement(); // Order

					Logger.debug("orderexport2...pushing successful order");
					successfulOrders.push(currentOrder.getOrderNo());

				}

			}


		} //orders loop

		xmlWriter.writeEndElement(); // Orders
		xmlWriter.writeEndDocument();

		xmlWriter.flush();
		xmlWriter.close();
		fileWriter.flush();
		fileWriter.close();

		// Remove any nodes with errors and update the file
		var fileReader: FileReader = new FileReader(file, "utf-8");
		var xmlContent: String = fileReader.getString();
		var myOrdersXML: XML = new XML(xmlContent);
		for (var myOrderPos: Number = myOrdersXML.Order.length() - 1; myOrderPos >= 0; myOrderPos--) {
			if (myOrdersXML.Order[myOrderPos].OrderHasError != null && myOrdersXML.Order[myOrderPos].OrderHasError == "True") {
				Logger.debug("(PFS911) EXPORT FAILED FOR SINGLE ORDER: Removed failed order {0} from output XML", myOrdersXML.Order[myOrderPos].Header.WebStoreOrderID);
				pdict.HasErrors = true;
				delete myOrdersXML.Order[myOrderPos];
			}
			//myOrderPos++;
		}
		var fileComplete: FileWriter = new FileWriter(file, "utf-8");
		fileComplete.write("<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n" + myOrdersXML.toXMLString());
		fileComplete.flush();
		fileComplete.close();

		// Send File and set DW Export Status
		try {
			if (myOrdersXML.Order.length() > 0) {
				if (uploadSFTP(file)) {
					for (var successCount = 0; successCount < successfulOrders.length; successCount++) {
						successfulOrdersCumulative.push(successfulOrders[successCount]);
					}
					//successfulOrders.forEach(setExportSuccess);
				} else {
					this.addError("500", "Connection Error - Unable to connect to SFTP Server!", 1);
					return [this.serviceErrors, null, null];
				}
			}
			for (var failedCount = 0; failedCount < failedOrders.length; failedCount++) {
				failedOrdersCumulative.push(failedOrders[failedCount]);
			}
			//failedOrders.forEach(setExportFailure);
			responseCode.put(1, myOrdersXML.Order.length().toString());

		} catch (e) {
			var loc = e;
			if (e.message.indexOf("java.net.UnknownHostException") > 0) {
				this.addError("500", "Connection Error - Host not found!", 1);
			} else {
				this.addError("499", "Unexpected/Unhandled error occurred: " + e.message, 2);
			}
			return [this.serviceErrors, null, null];
		}



	}
	return [responseCode, successfulOrdersCumulative, failedOrdersCumulative];

}

/**
 * Sets the Order Export status for a given order
 *
 * @input - xWriter XMLIndentingStreamWriter for output document
 * @input - currentOrder Order that needs to be exported
 */
function setExportSuccess(orderNo: string) {
	setExportStatus(orderNo, Order.EXPORT_STATUS_EXPORTED);
}

function setExportFailure(orderNo: string) {
	setExportStatus(orderNo, Order.EXPORT_STATUS_FAILED);
}

function setExportStatus(orderNo: string, status: Number) {
	var o: Order = dw.order.OrderMgr.queryOrder("orderNo={0}", orderNo);
	o.setExportStatus(status);
	o.custom.orderExportDate = dw.util.DateUtils.nowForSite();
}


/**
 *  Upload a given file name via SFTP
 */
function uploadSFTP(file: File): Boolean {
	var isSuccess: Boolean = false;
	var debug = (System.DEVELOPMENT_SYSTEM == System.getInstanceType()) ? true : false;

	if (file == null || !file.isFile()) {
		Logger.error("Order export SFTP ERROR: file object is not a file!");
		return PIPELET_ERROR;
	}

	var ftpServer = Site.getCurrent().getCustomPreferenceValue("jde_SFTPServer");
	var ftpUser = Site.getCurrent().getCustomPreferenceValue("jde_SFTPUserName");
	var ftpPassword = Site.getCurrent().getCustomPreferenceValue("jde_SFTPPassword");
	var ftpPath = Site.getCurrent().getCustomPreferenceValue("jde_orderExportSFTPPath");
	var ftpPort = 22;
	try {
		ftpPort = Site.getCurrent().getCustomPreferenceValue("jde_SFTPPort");
	} catch (e) {}

	if (empty(ftpServer) || empty(ftpUser) || empty(ftpPassword) || empty(ftpPath)) {
		Logger.error("Order Export SFTP ERROR: site preferences not defined - server/{0};port/{1};user/{2};password/{3};path/{4} not set!\n", ftpServer, ftpPort, ftpUser, ftpPassword, ftpPath);
		return PIPELET_ERROR;
	}

	if (debug) {
		Logger.debug("Order Export SFTP: Connecting to SFTP:");
		Logger.debug("server   = {0}", ftpServer);
		Logger.debug("port     = {0}", ftpPort);
		Logger.debug("user     = {0}", ftpUser);
		Logger.debug("password = {0}", ftpPassword);
		Logger.debug("path     = {0}", ftpPath);
		Logger.debug("");
	}

	//
	// ftp each file and afterwards delete it from the server
	//
	var sftp: SFTPClient = new SFTPClient();
	sftp.setTimeout(10000);
	if (sftp.connect(ftpServer, ftpPort, ftpUser, ftpPassword) && sftp.connected) {

		if (debug) Logger.debug("Order Export SFTP: Uploading order file:", file.fullPath);
		var path = ftpPath; // + (ftpPath.match(/\/$/) ? '' : '/');
		var isUploaded = sftp.putBinary(path + "/" + file.name, file);
		if (!isUploaded) {
			var errSFTP = sftp.errorMessage;
			Logger.error("Order Export SFTP: Failed to upload file " + file.fullPath + " : " + errSFTP);
			isSuccess = false;
		} else {
			// SUCCESS - set orders to Exported
			isSuccess = true;
		}

	} else {
		Logger.error("Order Export SFTP ERROR: Can not establish ftp connection to {0}!", ftpServer);
		isSuccess = false;
	}
	sftp.disconnect();
	return isSuccess;
}


/**
 * Adds the Header to the Order XML
 *
 * @input - xWriter XMLIndentingStreamWriter for output document
 * @input - currentOrder Order that needs to be exported
 */
function addOrderHeader(serviceProvider: Object, xWriter: XMLIndentingStreamWriter, currentOrder: Order, ForShipment: Shipment): Boolean {
	var customer: Customer = currentOrder.getCustomer();
	var priceAdjustments: Collection = currentOrder.priceAdjustments;
	var retvalue: Boolean = true;

	xWriter.writeStartElement("Header");

	///////////////////////////////////
	// Header Fields
	///////////////////////////////////

	// StoreID
	addXMLElement(xWriter, "StoreID", serviceProvider.getStoreID());

	// WebStoreOrderID
	addXMLElement(xWriter, "WebStoreOrderID", currentOrder.orderNo);

	// AgentID - not used here - written custom by int{Client} cartridge - libOrderExportCustom.ds
	// AgentID2 - not used here - written custom by int{Client} cartridge - libOrderExportCustom.ds


	//Multiship
	// CustomerPO
	if (ForShipment != null) {
		addXMLElement(xWriter, "CustomerPO", ForShipment.custom.shipSequenceNumber);

	}
	if (ForShipment != null) {
		if ('iCommerceIsStorePickup' in ForShipment.custom && ForShipment.custom.iCommerceIsStorePickup) {
			addXMLElement(xWriter, "InStorePickupStoreID", ForShipment.custom.iCommercestoreid);
		}
	}



	// OrderDate
	var calendar: Calendar = new Calendar(currentOrder.creationDate);
	calendar.add(dw.util.Calendar.SECOND, dw.system.Site.getCurrent().getTimezoneOffset() / 1000);
	var orderDateDW: Date = calendar.getTime();
	var orderDate: String = orderDateDW.getFullYear() + "-" + (orderDateDW.getMonth() + 1) + "-" + orderDateDW.getDate();
	addXMLElement(xWriter, "OrderDate", orderDate);

	// OrderTime
	var orderTime: String = orderDateDW.getHours() + ":" + orderDateDW.getMinutes() + ":" + orderDateDW.getSeconds();
	addXMLElement(xWriter, "OrderTime", orderTime);

	// CustomerID
	if (customer && customer.profile) {
		addXMLElement(xWriter, "CustomerID", customer.profile.customerNo);
	}

	// CustomerPO - not used

	// PreferredLanguage
	var prefLang: String = "E";

	//##################################################################################################################################################################
	//This new preference sendOrderLocaleToJDE was created as on Aug 31 2012 due to the issue found in PreferredLanguage value. Existing code was setting the tag value
	//based on customer's profile. It created issues for non registered customers who do not have profile and also if order had different locale than customer's  profile.
	//As per discussion with JDE team, they need to use Order's local and not customer'e locale. Following change is based on site preference to make it backward compatible.
	//##################################################################################################################################################################

	//##################################################################################################################################################################
	//
	//*** PRE-Requisite: Please note that your 'Order' system object should have custom attribute called as localeID that gets set to website's current locale value
	// 					 during order completion process in COPlaceOrder.xml. Otherwise it will just default to E.
	//
	//##################################################################################################################################################################
	//DG Sep 2012
	if ('jde_sendOrderLocaleToJDE' in dw.system.Site.getCurrent().preferences.custom && dw.system.Site.getCurrent().preferences.custom.jde_sendOrderLocaleToJDE) {
		try {

			var orderLocale: dw.util.Locale = dw.util.Locale.getLocale(currentOrder.custom.localeID);
			var langCode: String = orderLocale.getLanguage();
			//locale properties file is used to get one character language code needed for JDE.

			prefLang = dw.web.Resource.msg("locale." + langCode.toLowerCase(), 'locale', 'E');

		} catch (e) {
			prefLang = "E";
		}
		if (prefLang == "") {
			prefLang = "E";
		}
	} else {
		if (customer && customer.getProfile()) {
			prefLang = dw.web.Resource.msg("locale." + customer.getProfile().preferredLocale, 'locale', 'E');
		} else {
			prefLang = "E";
		}
	}

	addXMLElement(xWriter, "PreferredLanguage", prefLang);

	// CurrencyID
	addXMLElement(xWriter, "CurrencyID", currentOrder.getCurrencyCode());

	// CampaignID, PromotionID, PromotionCode
	var campaignIDs: HashMap = new HashMap();
	var promotionIDs: HashMap = new HashMap();
	var promotionCoupons: HashMap = new HashMap();
	try {
		for each(var priceAdjustment: PriceAdjustment in priceAdjustments) {
			var promotion: Promotion = priceAdjustment.getPromotion();
			if (!empty(promotion)) {
				if (promotion.campaign && !campaignIDs.containsKey(promotion.campaign.ID)) {
					campaignIDs.put(promotion.campaign.ID, true);
				}
				if (promotion.ID && !promotionIDs.containsKey(promotion.ID)) {
					promotionIDs.put(promotion.ID, true);
				}
			} else if ('promotionID' in priceAdjustment) {
				promotionIDs.put(priceAdjustment.promotionID, true);
			}
			for each(var couponLineItem: CouponLineItem in currentOrder.getCouponLineItems()) {
				if (!promotionCoupons.containsKey(couponLineItem.couponCode)) {
					promotionCoupons.put(couponLineItem.couponCode, true);
				}
			}
		}

		for each(var productLineItem: ProductLineItem in currentOrder.productLineItems) {
			for each(var priceAdjustment: PriceAdjustment in productLineItem.priceAdjustments) {
				var promotion: Promotion = priceAdjustment.getPromotion();
				if (!empty(promotion)) {
					if (promotion.campaign && !campaignIDs.containsKey(promotion.campaign.ID)) {
						campaignIDs.put(promotion.campaign.ID, true);
					}
					if (promotion.ID && !promotionIDs.containsKey(promotion.ID)) {
						promotionIDs.put(promotion.ID, true);
					}
				} else if ('promotionID' in priceAdjustment) {
					promotionIDs.put(priceAdjustment.promotionID, true);
				}
				for each(var couponLineItem: CouponLineItem in currentOrder.getCouponLineItems()) {
					if (!promotionCoupons.containsKey(couponLineItem.couponCode)) {
						promotionCoupons.put(couponLineItem.couponCode, true);
					}
				}
			}
		}
	} catch (e) {
		Logger.error("Promotion error! Promotion for priceAdjustment object is NULL. Order Number = " + currentOrder.getOrderNo());
		Logger.error("Error Message : " + e.message);
		retvalue = false;
	}

	if (campaignIDs.length > 0) {
		addXMLElement(xWriter, "CampaignID", getIteratorAsString(campaignIDs.keySet().iterator(), "|"));
	}
	if (promotionIDs.length > 0) {
		addXMLElement(xWriter, "PromotionID", getIteratorAsString(promotionIDs.keySet().iterator(), "|"));
	}
	if (promotionCoupons.length > 0) {
		addXMLElement(xWriter, "PromotionsCode", getIteratorAsString(promotionCoupons.keySet().iterator(), "|"));
	}


	// EmployeePromotionApplied - not used

	// AffiliateAttribute1, AffiliateAttribute2, AffiliateAttribute3 - not used here - written custom by int{Client} cartridge - libOrderExportCustom.ds 

	// SourceCode
	if (!empty(currentOrder.sourceCode)) {
		addXMLElement(xWriter, "SourceCode", currentOrder.sourceCode);
	}

	// SourceCodeGroup
	if (!empty(currentOrder.sourceCodeGroup)) {
		addXMLElement(xWriter, "SourceCodeGroup", currentOrder.sourceCodeGroup.ID);
	}
	Logger.debug("Order export2:Before order header custom");
	//customization hook
	addOrderHeaderCustom(xWriter, currentOrder, ForShipment);

	// ReferringURL, Keyword, SearchType - not used here - written custom by int{Client} cartridge - libOrderExportCustom.ds


	////////////////////////////////////////
	// Order Notes
	////////////////////////////////////////
	try {
		if (Site.getCurrent().preferences.custom.jde_sendOrderNotes == true) {

			var notes: Iterator = currentOrder.getNotes().iterator();

			if (notes.hasNext()) {
				xWriter.writeStartElement("OrderNotes");

				try {
					while (notes.hasNext()) {
						var note = notes.next();
						if (!empty(note.subject)) {

							//Retrieve call disposition record from the custom object
							var orderNoteCode: string;
							var orderNoteDescription: string;
							var coSeekableIterator: SeekableIterator = CustomObjectMgr.queryCustomObjects("CallDisposition", "custom.Code = '" + note.subject + "'", "custom.Code");
							if (coSeekableIterator.getCount() > 0) {
								var code = coSeekableIterator.next();
								orderNoteCode = note.subject;
								orderNoteDescription = code.custom.Description;
							} else {
								orderNoteCode = "";
								orderNoteDescription = note.subject;
							}

							xWriter.writeStartElement("OrderNote");

							// OrderNoteCode
							addXMLElement(xWriter, "OrderNoteCode", orderNoteCode);

							// OrderNoteDescription
							addXMLElement(xWriter, "OrderNoteDescription", orderNoteDescription);

							// OrderNoteText
							addXMLElement(xWriter, "OrderNoteText", note.text);

							xWriter.writeEndElement(); // OrderNote
							
							coSeekableIterator.close();
							Logger.debug("Order Note Code={0}, Order Note Description={1}, Order Note Text={2}", orderNoteCode, orderNoteDescription, note.text);
						}
					}
				} catch (exOrderNote) {
					Logger.debug("Non-critical ERROR writing Order Notes (check that CallDisposition custom object exists) - {0}", exOrderNote.message);
				}

				xWriter.writeEndElement(); // OrderNotes
			}

		}
	} catch (e) {}

	xWriter.writeEndElement(); // Header
	Logger.debug("Order Export2 : end of order header");
	return retvalue;

}

/**
 * Adds the LineItems to the Order XML
 *
 * @input - xWriter XMLIndentingStreamWriter for output document
 * @input - currentOrder Order that needs to be exported
 */
function addOrderLineItems(serviceProvider: Object, xWriter: XMLIndentingStreamWriter, currentOrder: Order, ForShipment: Shipment): Boolean {
	var returnValue: Object = null;

	var shipmentIndex: Number = 0;

	if (!empty(currentOrder.productLineItems)) {
		var lineItemArray: Array = new Array();

		var productLineItems: Collection = currentOrder.productLineItems;


		var lineItemRequest = null;

		var productLineItem: ProductLineItem;
		var productLineIndex = 0;

		Logger.debug("Order export2: Adding line items");

		xWriter.writeStartElement("LineItems");
		var shipment: Shipment = ForShipment;

		shipmentIndex++;
		if (!empty(shipment.productLineItems)) {
			//Commented since it is nonTransactional.
			//shipment.custom.shipSequenceNumber = shipmentIndex;
			// Logger.debug("Number of PLIs = {0}", shipment.productLineItems.length);
			var shipmentProductIndex: Number = 0;
			var writeBundleLineItemsWParentRef: Boolean = false;
			for each(var productLineItem: ProductLineItem in shipment.productLineItems) {
					writeBundleLineItemsWParentRef = false;
					productLineIndex++;
					shipmentProductIndex++;
					if (productLineItem.product.isBundle()) {
						try {
							var arrtemp: Array;
							if ('jde_sendBundleParentInExport' in dw.system.Site.getCurrent().preferences.custom && dw.system.Site.getCurrent().preferences.custom.jde_sendBundleParentInExport) {

								//***** Enhancement name: Write Bundle parent in order export with prices,promotions etc at parent level and include bundle components with refrence to bundle parent line number. 
								writeBundleLineItemsWParentRef = true;
							} else {
								arrtemp = addBundleLineItems(xWriter, productLineItem, currentOrder, shipment, shipmentProductIndex, productLineIndex, shipmentIndex, productPriceAdj, bonusProduct, productDiscounts, productTotalDiscounts, productCoupons, orderCoupons, orderDiscounts, orderSourceCodes, discountGross);
								if (arrtemp != null && !empty(arrtemp)) {
									productLineIndex = arrtemp[0] - 1;
									shipmentProductIndex = arrtemp[1] - 1;

								}
								// NO PROCESSING ANYTHING AFTER THIS LINE THIS LINE SINCE ITS HANDLED IN THE FUNCTION.
								continue;

							}
						} catch (eLineItemsCustom) {}
					}

					// need to check the rebate map to determine if there is a discount
					// at the line item level for this product in the order
					var itemCode: String = "";
					if (productLineItem.product != null) {
						itemCode = productLineItem.product.ID;
					} else {
						itemCode = productLineItem.productID;
					}
					if (productLineItem.quantity.value <= 0) {
						// Logger.debug("The number of ordered items have to been greater than 0.");
						xWriter.writeEndElement(); // LineItems
						return false;
					}

					var qty: Number = productLineItem.quantity.value;
					var unitNetPrice: Money = productLineItem.adjustedNetPrice.divide(qty);
					var unitGrossPrice: Money = productLineItem.netPrice.divide(qty); // per Jeff's email this should be the "non-discounted unit price"
					var lineNetPrice: Money = productLineItem.adjustedNetPrice;
					var discount: Money = new Money(0, productLineItem.netPrice.currencyCode);

					var finalNetUnitPrice: Money = productLineItem.custom.iCommerceFinalNetUnitPrice;
					
					var finalUnitDiscountedAmount: Money = !empty(productLineItem.custom.iCommerceFinalUnitDiscountedAmount)?(new Money(productLineItem.custom.iCommerceFinalUnitDiscountedAmount, productLineItem.netPrice.currencyCode) + shouldAvoidRounding):new Money(0.0, productLineItem.netPrice.currencyCode);
					var finalLineNetPrice: Money = !empty(productLineItem.custom.iCommerceFinalLineNetPrice)?(new Money(productLineItem.custom.iCommerceFinalLineNetPrice, productLineItem.netPrice.currencyCode) + shouldAvoidRounding):new Money(0.0, productLineItem.netPrice.currencyCode);
					
					var finalGrossUnitPrice: Money = !empty(productLineItem.custom.iCommerceFinalGrossUnitPrice)?(new Money(productLineItem.custom.iCommerceFinalGrossUnitPrice, productLineItem.netPrice.currencyCode) + shouldAvoidRounding):new Money(0.0, productLineItem.netPrice.currencyCode);
					var finalLineTax: Money = !empty(productLineItem.custom.iCommerceFinalLineTax)?(new Money(productLineItem.custom.iCommerceFinalLineTax, productLineItem.netPrice.currencyCode) + shouldAvoidRounding):new Money(0.0, productLineItem.netPrice.currencyCode);
					

					for each(var priceAdjustment: PriceAdjustment in productLineItem.priceAdjustments) {
						discount = discount.add(priceAdjustment.netPrice);
					}

					// Logger.debug("discount={0}, unitGrossPrice={1}, unitNetPrice={2}, units = {3}", discount.value,unitGrossPrice.value,unitNetPrice.value, productLineItem.quantity.value);

					var quantity: String = productLineItem.quantity.value;
					var shipment: Shipment = productLineItem.shipment;

					xWriter.writeStartElement("LineItem");

					// LineNumber
					addXMLElement(xWriter, "LineNumber", productLineIndex);
					//persisting that exact line number that is exported to PFS
					//Commented since it is Transactional. 
					//productLineItem.custom.pfs_ExportPosition = "" + productLineIndex;

					// RelatedLineNumber - not used

					// LineItemID
					addXMLElement(xWriter, "LineItemID", productLineIndex);

					// ProductID
					addXMLElement(xWriter, "ProductID", itemCode);

					// LineItemName
					addXMLElement(xWriter, "LineItemName", prepareStringForJDE(productLineItem.productName) || prepareStringForJDE(itemCode));

					// AltName - not used

					// StringAttribute1 - StringAttribute10 and NumberAttribute1 - NumberAttribute3 - not used here - written custom by int{Client} cartridge - libOrderExportCustom.ds

					// ThumbnailURL
					if (productLineItem.product && productLineItem.product.thumbnail) {
						addXMLElement(xWriter, "ThumbnailURL", productLineItem.product.thumbnail.absURL);
					}

					// Quantity
					addXMLElement(xWriter, "Quantity", productLineItem.quantity.value);

					xWriter.writeStartElement("Discounts");

					if ('iCommerceOrderExportDiscountXml' in productLineItem.custom && !empty(productLineItem.custom.iCommerceOrderExportDiscountXml) && (productLineItem.custom.iCommerceOrderExportDiscountXml != "")) {
						var productDiscounts: Array = new Array();

						try {
							productDiscounts = JSON.parse(productLineItem.custom.iCommerceOrderExportDiscountXml);

						} catch (e) {
							var a = e;
						}
						for each(var discount in productDiscounts) {

							xWriter.writeStartElement("Discount");
							addXMLElement(xWriter, "DiscountName", discount.DiscountName);
							addXMLElement(xWriter, "DiscountCode", discount.DiscountCode);
							addXMLElement(xWriter, "DiscountQuantity", discount.DiscountQuantity);
							addXMLElement(xWriter, "DiscountAmount", discount.DiscountAmount);
							xWriter.writeEndElement(); // Discount

						}




						//xWriter.writeCharacters(productLineItem.custom.iCommerceOrderExportDiscountXml.toString());

					}

					// Discounts
					xWriter.writeEndElement(); // Discounts

					// This condition is needed for sites that have GROSS as taxation policy and calculates tax on DW based on tax tables. DW tax calculation for GROSS taxation is needed for GMV reporting reasons to report accurate net merchandise value. 
					// It breaks amounts as net prices and tax on DW side. If SO export needs gross and net after this breakup, following pfs_SendGrossPriceinOrderExport pref needs o be true. 
					if ('jde_sendGrossPriceinOrderExport' in dw.system.Site.getCurrent().preferences.custom && dw.system.Site.getCurrent().preferences.custom.jde_sendGrossPriceinOrderExport) {
						writeGrossDiscountPrices(xWriter, currentOrder, productLineItem);
					} else { //else1




						// GrossUnitPrice
						addXMLElement(xWriter, "GrossUnitPrice", finalGrossUnitPrice);

						// NetUnitPrice
						addXMLElement(xWriter, "NetUnitPrice", finalNetUnitPrice);

						// UnitDiscountedAmount
						addXMLElement(xWriter, "UnitDiscountedAmount", finalUnitDiscountedAmount);

						// LineNetPrice
						addXMLElement(xWriter, "LineNetPrice", finalLineNetPrice);

						// LineTax
						addXMLElement(xWriter, "LineTax", finalLineTax);
					} //end of jde_sendGrossPriceinOrderExport

					// ShippingMethodID, ShippingAmount, ShippingGrossPrice, ShippingDiscount, ShippingNetPrice, ShippingTax, ShippingPromotionID, ShippingPromotionCode - not used

					// ShipSequenceNumber
					addXMLElement(xWriter, "ShipSequenceNumber", shipmentIndex);

					// GiftAttribute1-4, GiftRecipientName - not used

					///////////////////////////////////////////
					// Gift Card Details
					///////////////////////////////////////////
					try {
						// add virtual/digital gift card detail
						addGiftCardDetail(xWriter, productLineItem);
					} catch (e) {}

					///////////////////////////////////////////
					// Customization hook
					///////////////////////////////////////////         			
					
					try {
						addLineItemRequestCustom(xWriter, productLineItem, shipment);
					} catch (e) {}

					
					// Add discount lines to discount node jpm
					//if (!empty(currentOrder.priceAdjustments) || hasDetailPromo) {
					//	lineDiscountRequests.discount = lineDiscountArray;
					//	lineItemRequest.discounts = lineDiscountRequests;
					//}

					// Need to pass Parent item ref for Bundle parent item as well: As requested by JDE team
					//DG start
					if (writeBundleLineItemsWParentRef) {
						addXMLElement(xWriter, "BundleParentLineItemNumber", productLineIndex);
					} //DG end.

					xWriter.writeEndElement(); // LineItem

					//==========================================================================================
					//***** Enhancement name: Write Bundle parent in order export with prices,promotions etc at 
					//	parent level and include bundle components with refrence to bundle parent line number.
					//==========================================================================================
					//Write components for bundle-parent already written above with parent line number reference.
					//DG start
					var arrtemp: Array;
					if (writeBundleLineItemsWParentRef) {
						arrtemp = addBundleLineItemsWithParentRef(xWriter, productLineItem, currentOrder, shipment, shipmentProductIndex, productLineIndex + 1, shipmentIndex, productLineIndex);
						if (arrtemp != null && !empty(arrtemp)) {
							productLineIndex = arrtemp[0] - 1;
							shipmentProductIndex = arrtemp[1] - 1;

						}

					}
					//DG end

				} // each product lineitem

		} // !empty(shipment.productLineItems)

		Logger.debug("Order export2: end of Adding line items");

		xWriter.writeEndElement(); // LineItems
		return true;
	}
}

/*
 *Split demandware bundle items to individual line items -- KP
 */
function addBundleLineItems(xWriter: XMLIndentingStreamWriter, productLineItem: ProductLineItem, currentOrder: Order, shipment: Shipment, shipmentProductIndex: Number, productLineIndex: Number, shipmentIndex: Number, productPriceAdj: HashMap, bonusProduct: HashMap, productDiscounts: HashMap, productTotalDiscounts: HashMap, productCoupons: HashMap, orderCoupons: HashMap, orderDiscounts: HashMap, orderSourceCodes: HashMap, discountGross: Money): Array {
	//************************ product bundle splitting *********************************
	var bundleproductstotalqty: Number = 0;
	var i = 0;
	for each(var bli: ProductLineItem in productLineItem.bundledProductLineItems) {
		bundleproductstotalqty = bundleproductstotalqty + bli.quantity.value;
	}

	var x: Number = productLineIndex;
	for each(var bli: ProductLineItem in productLineItem.bundledProductLineItems) {
		var bprprice: Money = bli.proratedPrice;
		var templineDiscountArray: Array = new Array();
		var bundledProduct: dw.catalog.Product = bli.product;
		var qty: Number = bli.quantityValue;

		var productunitprice: Money = productLineItem.adjustedNetPrice.divide(bundleproductstotalqty);
		var productnetprice: Money = productunitprice * qty;
		var producttax: Money = productLineItem.adjustedTax.divide(bundleproductstotalqty) * qty;

		var tempMerchandizeGross = currentOrder.defaultShipment.adjustedMerchandizeTotalPrice; // - productnetprice;
		var templineNetPriceValue: Money = 0;
		var templineNetPriceDiff: Money = 0;

		xWriter.writeStartElement("LineItem");

		/////////////////////////////////////////////
		// Discounts
		/////////////////////////////////////////////
		var lineDiscountArray: Array = null;
		lineDiscountArray = new Array();
		var hasDetailPromo: Boolean = false;
		var promoNetDiscountAmountTotal: Money = 0;
		var lineNetPriceValue: Money = 0;
		var lineNetPriceDiff: Money = 0;
		var finalNetUnitPrice: Money = 0;
		var finalUnitDiscountedAmount: Money = 0;
		var finalLineNetPrice: Money = 0;
		var finalGrossUnitPrice: Money = 0;
		var finalLineTax: Money = 0;
		var priceAdjNetPrice: Money = 0;
		var promoNetPriceAdj: Money = 0;
		var prodDiscount: Boolean = false;


		// Order Level Discounts will be spread across all Product Line Items jpm
		if (!empty(currentOrder.priceAdjustments)) {
			var allproductCategories: Collection;
			var productID: String;
			// Check for Non-Qualifying Products on Order Level Discounts jpm
			if (productLineItem.product.categorized == false) {
				allproductCategories = productLineItem.product.masterProduct.allCategories;
				productID = productLineItem.product.masterProduct.ID;
			} else {
				allproductCategories = productLineItem.product.allCategories;
				productID = productLineItem.productID;
			}
			var isExcluded: Boolean = checkOrderPromotion(currentOrder.priceAdjustments, productID, allproductCategories);
			if (isExcluded == false) {
				var lineNetPriceAdj: Money = 0;
				var lineNetDiscountAmount: Money = 0;
				if (hasDetailPromo) {
					lineNetDiscountAmount = (productnetprice - priceAdjNetPrice) * (discountGross / tempMerchandizeGross);
					lineNetPriceAdj = (productnetprice - priceAdjNetPrice) - lineNetDiscountAmount;
				} else {
					lineNetDiscountAmount = productnetprice * (discountGross / tempMerchandizeGross);
					lineNetPriceAdj = productnetprice - lineNetDiscountAmount;
				}
				finalNetUnitPrice = Math.round((lineNetPriceAdj / qty) * 100) / 100;
				finalLineNetPrice = Math.round(lineNetPriceAdj * 100) / 100;
				prodDiscount = true;
			}
		}

		//Write out top level elements first, then discounts
		addXMLElement(xWriter, "LineNumber", x);
		addXMLElement(xWriter, "LineItemID", x);
		addXMLElement(xWriter, "ProductID", bundledProduct.ID);
		addXMLElement(xWriter, "LineItemName", prepareStringForJDE(bundledProduct.name));
		addXMLElement(xWriter, "GrossUnitPrice", productunitprice);
		addXMLElement(xWriter, "NetUnitPrice", finalNetUnitPrice || productunitprice);
		addXMLElement(xWriter, "LineNetPrice", finalLineNetPrice || productnetprice);
		addXMLElement(xWriter, "LineTax", producttax);
		addXMLElement(xWriter, "Quantity", qty);
		addXMLElement(xWriter, "ShipSequenceNumber", shipmentIndex);

		if (prodDiscount) {
			xWriter.writeStartElement("Discounts");

			// Add line level discount info jpm
			for each(var discountID: String in orderDiscounts.keySet()) {

				var orderDiscountID: String = discountID;
				var orderDiscountAmount = orderDiscounts.get(discountID);


				// DiscountCode
				var finalDiscountCode: string = "";
				if (orderCoupons.containsKey(discountID)) {
					finalDiscountCode = orderCoupons.get(discountID);
				}
				if (orderSourceCodes.containsKey(discountID)) {
					finalDiscountCode = orderSourceCodes.get(discountID);
				}

				// DiscountAmount
				var finalDiscountAmount: Money = 0;
				if (hasDetailPromo) {
					finalDiscountAmount = Math.round((productnetprice - priceAdjNetPrice) * (orderDiscountAmount / tempMerchandizeGross) * 100) / 100;
				} else {
					finalDiscountAmount = Math.round(productnetprice * (orderDiscountAmount / tempMerchandizeGross) * 100) / 100;
				}

				// Check and balance out the discount amount and unit price to match the gross line price (extended price)
				// Any difference will be added/subtracted from discount amount
				lineNetPriceValue = finalNetUnitPrice * qty + finalDiscountAmount;
				lineNetPriceDiff = productnetprice - lineNetPriceValue;
				if (lineNetPriceDiff != 0) {
					finalDiscountAmount = Math.round((finalDiscountAmount + lineNetPriceDiff) * 100) / 100;
				}

				if (finalDiscountAmount > 0) {
					xWriter.writeStartElement("Discount");

					addXMLElement(xWriter, "DiscountName", orderDiscountID.substr(0, 20)); // JDE can only accommodate 20 bytes
					addXMLElement(xWriter, "DiscountCode", finalDiscountCode);
					addXMLElement(xWriter, "DiscountQuantity", qty);
					addXMLElement(xWriter, "DiscountAmount", finalDiscountAmount);

					xWriter.writeEndElement(); // Discount
					Logger.debug("Order Level Discount Name={0}, Discount Code={1}, Discount Quantity={2}, Discount Amount={3}", orderDiscountID.substr(0, 20), finalDiscountCode, qty, finalDiscountAmount);
				}
			}

			xWriter.writeEndElement(); // Discounts
		}

		xWriter.writeEndElement(); //LineItem
		x++;
		productLineIndex++;
		shipmentProductIndex++;
	}

	var arr: Array = new Array(productLineIndex, shipmentProductIndex);
	return arr;
}


/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
//***** Enhancement name: Write Bundle parent in order export with prices,promotions etc at parent level and include bundle components with refrence to bundle parent line number.
// Enhancement to add bundle master item in export along with bundle components.
//This code adds  each of bundle components.
//Pricing and order level discounts are at bundle master level.
//Line level discounts are at bundle master level not component level.
//This call is based on site preference 
*/
function addBundleLineItemsWithParentRef(xWriter: XMLIndentingStreamWriter, productLineItem: ProductLineItem, currentOrder: Order, shipment: Shipment, shipmentProductIndex: Number, productLineIndex: Number, shipmentIndex: Number, parentLineItemNumber: Number): Array {
	try {

		var bprprice: Money = productLineItem.proratedPrice;
		var templineDiscountArray: Array = new Array();
		var bundleMasterProduct: dw.catalog.Product = productLineItem.product;
		var qty: Number = productLineItem.quantityValue;
		var bundleMasterLineNumber: Number = parentLineItemNumber;

		var x: Number = productLineIndex;


		//************************ write product bundle componets by splitting them in individual *********************************
		var bundleproductstotalqty: Number = 0;
		var i = 0;
		for each(var bli: ProductLineItem in productLineItem.bundledProductLineItems) {
			bundleproductstotalqty = bundleproductstotalqty + bli.quantity.value;
		}



		for each(var bli: ProductLineItem in productLineItem.bundledProductLineItems) {
			var bundledProduct: dw.catalog.Product = bli.product;
			var qty: Number = bli.quantityValue;
			xWriter.writeStartElement("LineItem");

			//Since we are writing the price and discount at parent, this component will have all those prices as zero.
			addXMLElement(xWriter, "LineNumber", x);
			addXMLElement(xWriter, "LineItemID", x);
			addXMLElement(xWriter, "ProductID", bundledProduct.ID);
			addXMLElement(xWriter, "LineItemName", prepareStringForJDE(bundledProduct.name));
			addXMLElement(xWriter, "GrossUnitPrice", "0.00");
			addXMLElement(xWriter, "NetUnitPrice", "0.00");
			addXMLElement(xWriter, "LineNetPrice", "0.00");
			addXMLElement(xWriter, "LineTax", "0.00");
			addXMLElement(xWriter, "Quantity", qty);
			addXMLElement(xWriter, "ShipSequenceNumber", shipmentIndex);
			addXMLElement(xWriter, "BundleParentLineItemNumber", parentLineItemNumber);
			
			xWriter.writeEndElement(); //LineItem
			x++;
			productLineIndex++;
			shipmentProductIndex++;
		}

		var arr: Array = new Array(productLineIndex, shipmentProductIndex);
		return arr;


	} catch (e) {

		Logger.debug("Error in function addBundleComponentsWithParentRef for order: {0} , Lineitem: {1}", currentOrder.orderNo, productLineItem.productID);
	}

}

/*
 *Check if product qualifies for the order level promotion jpm
 */
function checkOrderPromotion(priceAdjustments: Collection, productID: String, allproductCategories: Collection): Boolean {

	try {

		var priceAdjustments: Collection = priceAdjustments;
		for each(var priceAdjustment: PriceAdjustment in priceAdjustments) {

			var promotion: Promotion = priceAdjustment.getPromotion();
			if (!empty(promotion) && 'nonqualifyingProducts' in promotion.custom) {
				var nonqualifyingProducts: ArrayList = promotion.custom.nonqualifyingProducts;

				for (var i: Number = 0; i < nonqualifyingProducts.length; i++) {

					if (productID == nonqualifyingProducts[i]) {
						return true;
					} else {
						var productCategories: Iterator = allproductCategories.iterator();
						while (productCategories.hasNext()) {
							var productCategory = productCategories.next();
							if (productCategory.ID == nonqualifyingProducts[i]) {
								return true;
							}
						}
					}
				}
			}
		}
	} catch (ex) {
		return false;
	}
	return false;
}

/**
 * Adds Virtual/Digital Gift Card Detail
 */
function addGiftCardDetail(xWriter: XMLIndentingStreamWriter, productLineItem: ProductLineItem) {

	var toEmailAddress: string = productLineItem.custom.vgcRecipientEmail;
	var fromEmailAddress: string = productLineItem.custom.vgcFromEmail;
	var recipientName: string = productLineItem.custom.vgcRecipientName;
	var senderName: string = productLineItem.custom.vgcFromName;
	var giftMessage: string = productLineItem.custom.vgcGiftMessage;
	//
	// gcDetailRequest.imageURL will be set in addLineItemRequestCustom in libOrderExportCustom.ds
	//
	if (toEmailAddress != "") {
		xWriter.writeStartElement("GiftCard");

		addXMLElement(xWriter, "ToEmailAddress", toEmailAddress);
		addXMLElement(xWriter, "FromEmailAddress", fromEmailAddress);
		addXMLElement(xWriter, "RecipientName", recipientName);
		addXMLElement(xWriter, "SenderName", senderName);
		addXMLElement(xWriter, "GiftMessage", giftMessage);
		//addXMLElement(xWriter, "ImageURL", toEmailAddress)

		xWriter.writeEndElement(); // GiftCard
	}
}


/**
 * Adds the billing section to the order XML.
 */
function addBilling(serviceProvider: Object, xWriter: XMLIndentingStreamWriter, currentOrder: Order): Boolean {

	var billingAddress: OrderAddress = currentOrder.billingAddress;

	xWriter.writeStartElement("Billing");

	try {
		// FirstName
		addXMLElement(xWriter, "FirstName", billingAddress.firstName);

		// LastName
		addXMLElement(xWriter, "LastName", billingAddress.lastName);

		// Address1
		addXMLElement(xWriter, "Address1", billingAddress.address1);

		// Address2
		if (!empty(billingAddress.address2)) {
			addXMLElement(xWriter, "Address2", billingAddress.address2);
		}

		// PostalCode
		addXMLElement(xWriter, "PostalCode", billingAddress.postalCode);

		// City
		addXMLElement(xWriter, "City", billingAddress.city.substr(0, 25)); // JDE can handle only 25 characters for city

		// County
		try {
			if (billingAddress.custom.county != null) {
				addXMLElement(xWriter, "County", billingAddress.custom.county.substr(0, 25)); // JDE can handle only 25 characters for county.
			}
		} catch (e) {
			//Logger.debug("Error in Capturing County for Billing");
		}

		// State
		if (!empty(billingAddress.countryCode) && !empty(billingAddress.stateCode) && (billingAddress.countryCode == 'CA' || billingAddress.countryCode == 'US')) {
			addXMLElement(xWriter, "State", billingAddress.stateCode.toUpperCase());
		} else {
			addXMLElement(xWriter, "State", "");
		}

		// Country
		addXMLElement(xWriter, "Country", billingAddress.countryCode);

		// Company
		if (!empty(billingAddress.companyName)) {
			addXMLElement(xWriter, "Company", billingAddress.companyName);
		}

		// Phone
		if (!empty(billingAddress.phone)) {
			addXMLElement(xWriter, "Phone", billingAddress.phone);
		}

		// Email
		if ('email' in billingAddress.custom && !empty(billingAddress.custom.email)) {
			addXMLElement(xWriter, "Email", billingAddress.custom.email);
		} else {
			if (!empty(currentOrder.customerEmail)) addXMLElement(xWriter, "Email", currentOrder.customerEmail);
		}
		
	} catch (exBilling) {
		Logger.debug("BILLING Address error: {0}", exBilling.message);
		xWriter.writeEndElement(); // Billing
		return false;
	}

	xWriter.writeEndElement(); // Billing

	return true;

}

/**
 * Adds the payment section to the order XML.
 */
function addPayments(serviceProvider: Object, xWriter: XMLIndentingStreamWriter, currentOrder: Order, overrideCCSdrToken: String, ForShipment: Shipment): Boolean {

		var isPaymentOK: Boolean = true;

		xWriter.writeStartElement("Payments");

		//Online Gift Certificates
		Logger.debug("libOrderExport2: executing getOnlineGiftCertificatePaymentInstruments .......");
		isPaymentOK = getOnlineGiftCertificatePaymentInstruments(xWriter, currentOrder, ForShipment);

		//Payment Auth
		Logger.debug("libOrderExport2: executing getPaymentAuth .......");
		isPaymentOK = isPaymentOK && getPaymentAuth(serviceProvider, xWriter, currentOrder, overrideCCSdrToken, ForShipment);

		//PayPal Auth
		Logger.debug("libOrderExport2: executing getPayPalAuth .......");
		isPaymentOK = isPaymentOK && getPayPalAuth(xWriter, currentOrder);
		
		xWriter.writeEndElement(); // Payments

		return isPaymentOK;

}
	
/**
 * Gets the cybersource payment authorization data
 */
function getPaymentAuth(serviceProvider: Object, xWriter: XMLIndentingStreamWriter, currentOrder: Order, overrideCCSdrToken: String, ForShipment: Shipment): Boolean {

	var countPaymentInstruments = currentOrder.paymentInstruments.length;
	var isPaymentOK: Boolean = true;

	for (var i: Number = 1; i <= countPaymentInstruments; i++) {
		var payment: OrderPaymentInstrument = currentOrder.paymentInstruments[i - 1];

		if (currentOrder.getShipments().size() > 1 && ('jde_separateAuthPerShipment' in dw.system.Site.current.preferences.custom && dw.system.Site.current.preferences.custom.jde_separateAuthPerShipment)) {
			if (ForShipment != null) {

				if (ForShipment.ID != payment.custom.iCommerceShipmentRef) {
					Logger.error("libOrderExport2:Write Payments Skipped order since payment for shipment could not be located " + currentOrder.orderNo + ", ShipmentID:" + ForShipment.ID + ", payinstrument shipment reference:" + payment.custom.iCommerceShipmentRef);
					//isPaymentOK = false;
					continue;
				}
			}
		}
		var paymentTransaction: PaymentTransaction = payment.paymentTransaction;
		var transactionID: String = paymentTransaction.transactionID || "";
		var requestToken: String = paymentTransaction.custom.requestToken;
		var dmDecision: String = paymentTransaction.custom.dmDecision;
		var avsCode: String = paymentTransaction.custom.avsCode;
		var authCode: String = paymentTransaction.custom.authCode;
		var cvCode: String = paymentTransaction.custom.cvCode;
		var afsFactorCode: String = paymentTransaction.custom.afsFactorCode;
		var afsResult: String = paymentTransaction.custom.afsResult;
		var afsReasonCode: String = paymentTransaction.custom.afsReasonCode;
		// Logger.debug("PaymentMethodID: {0}", payment.paymentMethod);
		if (payment.paymentMethod == "CREDIT_CARD") {
			try {
				var transactionID: String = paymentTransaction.transactionID || "";
				if ((empty(payment.paymentTransaction.paymentProcessor)) || (!empty(payment.paymentTransaction.paymentProcessor))) {
					if (transactionID === "" || empty(paymentTransaction.custom.requestToken)) {
						//auth again.
						Logger.debug("libOrderExport2:Write Payments order " + currentOrder.orderNo + " , " + paymentTransaction.transactionID + "," + paymentTransaction.custom.requestToken);
						//continue;
					}

				}

				xWriter.writeStartElement("PaymentAuth");

				try {

					// PaymentSequence
					addXMLElement(xWriter, "PaymentSequence", i);

					// ShipSequenceNumber - not used

					// PaymentUsageType
					addXMLElement(xWriter, "PaymentUsageType", i == countPaymentInstruments ? "P" : "S");

					// auth_auth_avs
					addXMLElement(xWriter, "auth_auth_avs", avsCode);

					// auth_code
					addXMLElement(xWriter, "auth_code", authCode);

					// auth_cv_result
					addXMLElement(xWriter, "auth_cv_result", cvCode);

					// request_id
					addXMLElement(xWriter, "request_id", transactionID);

					// request_token
					addXMLElement(xWriter, "request_token", requestToken);

					// score_factors
					addXMLElement(xWriter, "score_factors", afsFactorCode);

					// score_rcode
					addXMLElement(xWriter, "score_rcode", afsResult);

					// score_result
					addXMLElement(xWriter, "score_result", afsReasonCode);

					// CardType
					addXMLElement(xWriter, "CardType", paymentTransaction.paymentInstrument.creditCardType);

					// decision
					addXMLElement(xWriter, "decision", dmDecision);

					// Custom fields (MerchantID, MerchantRefNo, etc)
					addPaymentAuthCustom(xWriter, currentOrder);

					//////////////////////////////////////
					// Credit Card Auth
					//////////////////////////////////////
					xWriter.writeStartElement("CreditCardAuth");

					try {
						// CreditCardAmt
						addXMLElement(xWriter, "CreditCardAmt", payment.paymentTransaction.amount.value + shouldAvoidRounding);

						// ExpMonth
						addXMLElement(xWriter, "ExpMonth", payment.creditCardExpirationMonth);

						// ExpYear
						addXMLElement(xWriter, "ExpYear", payment.creditCardExpirationYear);



						/////////////////////////////////////////
						// SDR Token
						/////////////////////////////////////////
						xWriter.writeStartElement("PFSRepositoryToken");

						try {
							// SystemID
							addXMLElement(xWriter, "SystemID", paymentTransaction.custom.PFSRepositorySystemID || Site.getCurrent().preferences.custom.ete_repositorySystemID);

							// Token
							addXMLElement(xWriter, "Token", overrideCCSdrToken || paymentTransaction.custom.PFSRepositoryToken);
						} catch (exToken) {
							dw.system.Logger.error("Could not write SDR Token for payment auth: {0}", exToken.message);
							isPaymentOK = false;
						}
						xWriter.writeEndElement(); // PFSRepositoryToken
					} catch (exCCAuth) {
						var a = exCCAuth;
						dw.system.Logger.error("Could not write CC Auth data for payment auth: {0}", exCCAuth.message);
						isPaymentOK = false;
					}
					xWriter.writeEndElement(); // CreditCardAuth
				} catch (exPaymentAuth) {
					dw.system.Logger.error("Could not write Payment Auth data: {0}", exPaymentAuth.message);
					isPaymentOK = false;
				}
				xWriter.writeEndElement(); // PaymentAuth

			} catch (e) {
				dw.system.Logger.error("Error with trying to detect payment processor: {0}", e.message);
			}
		}
	}
	return isPaymentOK;
}

/**
 * Gets the paypal payment authorization data
 */
function getPayPalAuth(xWriter: XMLIndentingStreamWriter, currentOrder: Order): Boolean {

	// PayPal Auth
	var isPaymentOK: Boolean = true;
	var countPaymentInstruments = currentOrder.paymentInstruments.length;

	for (var i = 1; i <= countPaymentInstruments; i++) {

		var payment: OrderPaymentInstrument = currentOrder.paymentInstruments[i - 1];
		if (payment.paymentMethod == "PayPal") {

			xWriter.writeStartElement("PayPalAuth");

			try {
				var paymentTransaction: PaymentTransaction = payment.paymentTransaction;

				// PaymentSequence
				addXMLElement(xWriter, "PaymentSequence", i);

				// PaymentUsageType
				addXMLElement(xWriter, "PaymentUsageType", (i == countPaymentInstruments) ? "P" : "S");

				// AuthorizationID
				addXMLElement(xWriter, "AuthorizationID", payment.custom.paypalAuthID);

				// PayPalOrderID
				addXMLElement(xWriter, "PayPalOrderID", paymentTransaction.transactionID);

				// PayerStatus
				if(!empty(payment.custom.paypalPayerStatus)){
					addXMLElement(xWriter, "PayerStatus", payment.custom.paypalPayerStatus.toString().toUpperCase());		
				}
			
				// AddressStatus
				var billingAddress: OrderAddress = currentOrder.billingAddress;
				addXMLElement(xWriter, "AddressStatus", billingAddress.custom.paypalAddressStatus.toString().toUpperCase());

				// AuthAmount
				addXMLElement(xWriter, "AuthAmount", paymentTransaction.amount);
			} catch (exPaypal) {
				dw.system.Logger.error("Could not write PayPal auth data: {0}", exPaypal.message);
				isPaymentOK = false;
			}
			xWriter.writeEndElement(); // PayPalAuth
		}

	}

	return isPaymentOK;
}

/**
 * Gets all used Online Gift Certificate tranasction data for the given Order.
 */
function getOnlineGiftCertificatePaymentInstruments(xWriter: XMLIndentingStreamWriter, currentOrder: Order, ForShipment: Shipment): Boolean {

	//Online Gift Certificates
	var countPaymentInstruments = currentOrder.paymentInstruments.length;
	for (var i: Number = 1; i <= countPaymentInstruments; i++) {
		var payment: OrderPaymentInstrument = currentOrder.paymentInstruments[i - 1];

		if (payment.paymentMethod == 'GIFT_CERTIFICATE') {
			if (ForShipment != null) {

				if (ForShipment.ID != payment.custom.iCommerceShipmentRef) {
					continue;
				}
			}

			xWriter.writeStartElement("GiftCertificate");

			// PaymentSequence
			addXMLElement(xWriter, "PaymentSequence", i);

			// PaymentUsageType
			addXMLElement(xWriter, "PaymentUsageType", i == countPaymentInstruments ? "P" : "S");

			// GiftCertificateNumber
			addXMLElement(xWriter, "GiftCertificateNumber", payment.giftCertificateCode);


			// GiftCertificateAmount
			addXMLElement(xWriter, "GiftCertificateAmount", payment.paymentTransaction.amount.value + shouldAvoidRounding);


			xWriter.writeEndElement(); // GiftCertificate
		}
	}

	return true;

}

/**
 * Adds the shipping section to the order XML.
 * @return shipmentSequenceNumber
 */
function addShipment(serviceProvider: Object, xWriter: XMLIndentingStreamWriter, currentOrder: Order, ForShipment: Shipment): Boolean {

	var isShipmentsOK: Boolean = true;

	xWriter.writeStartElement("Shipments");

	var oShipmentsColl: Collection = new ArrayList();
	try {
		if (ForShipment != null) {

			oShipmentsColl.add(currentOrder.getShipment(ForShipment.ID));

		} else {
			oShipmentsColl = currentOrder.shipments;


		}
	} catch (e) {

		oShipmentsColl = currentOrder.shipments;

	}
	Logger.debug("Order expport2:Writing shipments ");
	for each(var shipment: Shipment in oShipmentsColl) {



		var shippingingAddress: OrderAddress = shipment.shippingAddress;

		xWriter.writeStartElement("Shipment");

		try {

			// FirstName
			addXMLElement(xWriter, "FirstName", shippingingAddress.firstName);

			// LastName
			addXMLElement(xWriter, "LastName", shippingingAddress.lastName);

			// Address1
			addXMLElement(xWriter, "Address1", shippingingAddress.address1);

			// Address2
			if (!empty(shippingingAddress.address2)) addXMLElement(xWriter, "Address2", shippingingAddress.address2);

			// PostalCode
			addXMLElement(xWriter, "PostalCode", shippingingAddress.postalCode);

			// City
			addXMLElement(xWriter, "City", shippingingAddress.city.substr(0, 25)); // JDE can handle only 25 characters for city

			// County
			try {
				if (shippingingAddress.custom.county != null) {
					addXMLElement(xWriter, "County", shippingingAddress.custom.county.substr(0, 25)); // JDE can handle only 25 characters for county
				}
			} catch (e) {
				//Logger.debug("Error in Capturing County");
			}

			// State
			if (!empty(shippingingAddress.countryCode) && !empty(shippingingAddress.stateCode) && (shippingingAddress.countryCode == 'CA' || shippingingAddress.countryCode == 'US')) {
				addXMLElement(xWriter, "State", shippingingAddress.stateCode.toUpperCase());
			} else {
				addXMLElement(xWriter, "State", "");
			}

			// Country
			addXMLElement(xWriter, "Country", shippingingAddress.countryCode);

			// Company
			if (!empty(shippingingAddress.companyName)) {
				addXMLElement(xWriter, "Company", shippingingAddress.companyName);
			}

			// Phone
			if (!empty(shippingingAddress.phone)) {
				addXMLElement(xWriter, "Phone", shippingingAddress.phone);
			}

			// Email
			if ('email' in shippingingAddress.custom && !empty(shippingingAddress.custom.email)) {
				addXMLElement(xWriter, "Email", shippingingAddress.custom.email);
			} else {
				if (!empty(currentOrder.customerEmail)) {
					addXMLElement(xWriter, "Email", currentOrder.customerEmail);
				}
			}

			// GiftAttribute1-4 - used in customization hook

			// ShipSequenceNumber
			addXMLElement(xWriter, "ShipSequenceNumber", shipment.custom.shipSequenceNumber);

			// ShippingMethodID - used in customization hook

			// ShippingPromotionID, ShippingPromotionCode
			var finalShippingPromotionID: string = "";
			var finalShippingPromotionCode: string = "";
			var discount: Money = new Money(0, currentOrder.currencyCode);
			for each(var priceAdjustment: PriceAdjustment in shipment.shippingPriceAdjustments) {
				if ('jde_sendGrossPriceinOrderExport' in dw.system.Site.getCurrent().preferences.custom && dw.system.Site.getCurrent().preferences.custom.jde_sendGrossPriceinOrderExport) {
					discount = discount.add(priceAdjustment.grossPrice);
				} else {
					discount = discount.add(priceAdjustment.netPrice);
				}
				finalShippingPromotionID = priceAdjustment.promotionID.substr(0, 20);
				if (priceAdjustment.isBasedOnCoupon()) {
					finalShippingPromotionCode = priceAdjustment.couponLineItem.couponCode;
				}
				if (priceAdjustment.promotion != null) {
					if (priceAdjustment.promotion.isBasedOnSourceCodes() && !empty(currentOrder.sourceCodeGroup)) {
						var sourceCodeGroups: Iterator = priceAdjustment.promotion.getSourceCodeGroups().iterator();
						while (sourceCodeGroups.hasNext()) {
							var sourceCodeGroup = sourceCodeGroups.next();
							if (sourceCodeGroup.ID == currentOrder.sourceCodeGroup.ID) {
								finalShippingPromotionCode = currentOrder.sourceCode;
							}
						}
					}
				} else {
					if (currentOrder.sourceCode != null) {
						finalShippingPromotionCode = currentOrder.sourceCode;
					}
				}
			}
			addXMLElement(xWriter, "ShippingPromotionID", finalShippingPromotionID);
			addXMLElement(xWriter, "ShippingPromotionCode", finalShippingPromotionID);

			// ShippingGrossPrice
			addXMLElement(xWriter, "ShippingGrossPrice", shipment.adjustedShippingTotalGrossPrice.value + shouldAvoidRounding);

			// ShippingDiscount
			if (discount < 0) {
				addXMLElement(xWriter, "ShippingDiscount", discount - shouldAvoidRounding);
			} else {
				addXMLElement(xWriter, "ShippingDiscount", discount + shouldAvoidRounding);
			}



			if ('jde_sendGrossPriceinOrderExport' in dw.system.Site.getCurrent().preferences.custom && dw.system.Site.getCurrent().preferences.custom.jde_sendGrossPriceinOrderExport) {
				// ShippingNetPrice
				addXMLElement(xWriter, "ShippingNetPrice", shipment.adjustedShippingTotalGrossPrice.value + shouldAvoidRounding);

				var shipTax = 0.00;
				// ShippingTax
				addXMLElement(xWriter, "ShippingTax", shipTax + shouldAvoidRounding);
			} else {
				// ShippingNetPrice
				addXMLElement(xWriter, "ShippingNetPrice", shipment.adjustedShippingTotalNetPrice.value + shouldAvoidRounding);

				// ShippingTax
				addXMLElement(xWriter, "ShippingTax", shipment.shippingTotalTax.value + shouldAvoidRounding);
			}
			// Customization hook
			addShipmentCustom(xWriter, shipment);
		} catch (exShipment) {
			isShipmentsOK = false;
			Logger.error("Error processing shipment: {0}", exShipment.message);
		}

		xWriter.writeEndElement(); // Shipment
	}
	Logger.debug("Order expport2: end of Writing shipments ");
	xWriter.writeEndElement(); // Shipments
	return isShipmentsOK;
}


/**
 * Determines if the line item should split up into two because of the discount
 * rounding problem
 */
function splitItem(quantity: Number, discount: Number): Boolean {
	if (quantity <= 1 || empty(discount) || discount == 0) {
		return false;
	}
	if (getRoundingDiscrepancy(quantity, discount) != 0) {
		return true;
	}
	return false;
}

/**
 * Rounding discrepancy
 */
function getRoundingDiscrepancy(quantity: Number, discount: Number): Number {
	if (empty(quantity) || empty(discount) || discount == 0) {
		return 0;
	}
	var returnValue: Number = (discount - (discount / quantity).toFixed(2) * quantity).toFixed(2);
	return returnValue;
}

function removeWhitespaces(string: String): String {
	return string.replace(new RegExp(' ', "\g"), "");
}

function getIteratorAsString(it: Iterator, separator: String) {
	var returnValue = "";
	var sep = "";

	while (it.hasNext()) {
		returnValue += sep + it.next();
		sep = separator;
	}

	return returnValue;
}

function getDecryptedCCNumber(paymentInstrument: PaymentInstrument) {

	var cNumber = "";

	if (paymentInstrument.creditCardNumber != null) {
		var encryptedNumber: String = paymentInstrument.getEncryptedCreditCardNumber(dw.order.PaymentInstrument.ENCRYPTION_ALGORITHM_RSA, Site.getCurrent().getPreferences().custom.cs_PublicKey);
		cNumber = new dw.crypto.Cipher().decrypt(encryptedNumber, Site.getCurrent().getPreferences().custom.cs_PrivateKey, dw.order.PaymentInstrument.ENCRYPTION_ALGORITHM_RSA, null, 1);
		Logger.debug("libOrderExportSFTP: decrypted CC number before sending to SDR");
	}

	return cNumber.replace(/\s+/g, '');
}

function encryptBySDR(serviceProvider, val: String): String {

	var encrytionRequest = new serviceProvider.serviceReference.PFSRepositoryInsertData();

	encrytionRequest.PFSRepositoryInsertDataRequest = new serviceProvider.serviceReference.TPFSRepositoryInsertDataRequest();
	encrytionRequest.PFSRepositoryInsertDataRequest.timeout = serviceProvider.getTimeOut();
	encrytionRequest.PFSRepositoryInsertDataRequest.value = val;
	encrytionRequest.PFSRepositoryInsertDataRequest.sessionToken = serviceProvider.retrieveSessionToken();

	encrytionRequest.PFSRepositoryInsertDataRequest.PFSRepositoryToken = new serviceProvider.serviceReference.TPFSRepositoryToken();
	encrytionRequest.PFSRepositoryInsertDataRequest.PFSRepositoryToken.systemID = Site.getCurrent().preferences.custom.ete_repositorySystemID;


	var encryptionService: Stub = serviceProvider.serviceReference.getService("E2EService", "E2EServiceSoap");
	serviceProvider.setWebServiceURL(encryptionService);

	var response = encryptionService.PFSRepositoryInsertData(encrytionRequest);
	return response.PFSRepositoryInsertDataResult.PFSRepositoryToken.token;
}

function writeGrossDiscountPrices(xWriter: XMLIndentingStreamWriter, currentOrder: Order, productLineItem: ProductLineItem) {
	if ('jde_sendGrossPriceinOrderExport' in dw.system.Site.getCurrent().preferences.custom && dw.system.Site.getCurrent().preferences.custom.jde_sendGrossPriceinOrderExport) {
		try {


			/////////////////////////////////////////////
			// Discounts
			/////////////////////////////////////////////

			var discountTotal = 0;
			var finalLineTax: Money = 0.00 + shouldAvoidRounding;
			var qty: Number = productLineItem.quantity.value;
			xWriter.writeStartElement("Discounts");

			if (productLineItem.priceAdjustments.size() > 0) {
				// DiscountName
				for each(var priceadj: PriceAdjustment in productLineItem.priceAdjustments) {
					if (priceadj != null && priceadj.promotion != null && priceadj.promotion.promotionClass == 'PRODUCT') {

						xWriter.writeStartElement("Discount");

						//Discount Name
						addXMLElement(xWriter, "DiscountName", priceadj.promotionID.substr(0, 20)); // JDE can only accommodate 20 bytes

						//Discount Code
						var finalDiscountCode: string = "";
						if (priceadj.basedOnCoupon) {
							finalDiscountCode = priceadj.couponLineItem.couponCode;
						}
						if (priceadj.promotion.isBasedOnSourceCodes() && !empty(currentOrder.sourceCodeGroup)) {
							var sourceCodeGroups: Iterator = priceadj.promotion.getSourceCodeGroups().iterator();
							while (sourceCodeGroups.hasNext()) {
								var sourceCodeGroup = sourceCodeGroups.next();
								if (sourceCodeGroup.ID == currentOrder.sourceCodeGroup.ID) {
									finalDiscountCode = currentOrder.sourceCode;
								}
							}
						}
						addXMLElement(xWriter, "DiscountCode", finalDiscountCode);



						//Discount Qty	
						addXMLElement(xWriter, "DiscountQuantity", productLineItem.quantity.value);

						//Discount Amount
						var priceadjValue: Money = new Money(0, currentOrder.currencyCode);
						priceadjValue = priceadj.priceValue;
						discountTotal += priceadj.priceValue;
						addXMLElement(xWriter, "DiscountAmount", priceadjValue * -1);

						xWriter.writeEndElement(); // Discount
					}
				}
			}


			if (currentOrder.priceAdjustments.size() > 0) {
				for each(var i in currentOrder.priceAdjustments[0].proratedPrices.keySet()) {
					if (i.UUID == productLineItem.UUID) {
						xWriter.writeStartElement("Discount");

						//Discount Name
						addXMLElement(xWriter, "DiscountName", currentOrder.priceAdjustments[0].promotionID.substr(0, 20)); // JDE can only accommodate 20 bytes

						//Discount Code
						var finalDiscountCode: string = "";
						if (currentOrder.priceAdjustments[0].basedOnCoupon) {
							finalDiscountCode = currentOrder.priceAdjustments[0].couponLineItem.couponCode;
						}
						if (currentOrder.priceAdjustments[0].promotion != null && currentOrder.priceAdjustments[0].promotion.isBasedOnSourceCodes() && !empty(currentOrder.sourceCodeGroup)) {
							var sourceCodeGroups: Iterator = currentOrder.priceAdjustments[0].promotion.getSourceCodeGroups().iterator();
							while (sourceCodeGroups.hasNext()) {
								var sourceCodeGroup = sourceCodeGroups.next();
								if (sourceCodeGroup.ID == currentOrder.sourceCodeGroup.ID) {
									finalDiscountCode = currentOrder.sourceCode;
								}
							}
						}
						addXMLElement(xWriter, "DiscountCode", finalDiscountCode);

						//Discount Qty	
						addXMLElement(xWriter, "DiscountQuantity", productLineItem.quantity.value);
						//Discount Amount
						var proRatedValue: Money = new Money(0, currentOrder.currencyCode);
						proRatedValue = currentOrder.priceAdjustments[0].proratedPrices.get(i).value;
						discountTotal += currentOrder.priceAdjustments[0].proratedPrices.get(i).value;
						addXMLElement(xWriter, "DiscountAmount", proRatedValue * -1);

						xWriter.writeEndElement(); // Discount
					}
				}
			}

			xWriter.writeEndElement(); // Discounts



			//finalLineTax = productLineItem.adjustedTax.value + shouldAvoidRounding;

			// GrossUnitPrice
			addXMLElement(xWriter, "GrossUnitPrice", productLineItem.price.divide(qty));

			// NetUnitPrice
			var netunitprice = (Math.round(((productLineItem.price.value + (discountTotal)) / qty) * 100) / 100);
			addXMLElement(xWriter, "NetUnitPrice", netunitprice);

			// UnitDiscountedAmount
			addXMLElement(xWriter, "UnitDiscountedAmount", ((discountTotal) / qty));

			// LineNetPrice
			addXMLElement(xWriter, "LineNetPrice", netunitprice * qty);

			// LineTax
			addXMLElement(xWriter, "LineTax", finalLineTax);
		} catch (e) {
			var ex = e;
			Logger.error("Error in function writeGrossDiscountPrices-" + e.message);
			throw (e);

		}

	}

}


function checkIfMissingSDRAuth(currentOrder: Order): Boolean {
	var skipOrder: Boolean = false;

	//check if SDR missing
	for (var iPayInst: Number = 1; iPayInst <= currentOrder.paymentInstruments.length; iPayInst++) {

		var payment: OrderPaymentInstrument = currentOrder.paymentInstruments[iPayInst - 1];
		var paymentTransaction: PaymentTransaction = payment.paymentTransaction;

		// Logger.debug("PaymentMethodID: {0}", payment.paymentMethod);
		if (payment.paymentMethod == "CREDIT_CARD" && ((empty(payment.paymentTransaction.paymentProcessor)) || (!empty(payment.paymentTransaction.paymentProcessor)))) {
			skipOrder = true;
			return skipOrder;
			break;
		}
		// Logger.debug("PaymentMethodID: {0}", payment.paymentMethod);
		if (payment.paymentMethod == "CREDIT_CARD") {
			try {
				var transactionID: String = paymentTransaction.transactionID || "";
				if ((empty(payment.paymentTransaction.paymentProcessor)) || (!empty(payment.paymentTransaction.paymentProcessor))) {
					if (transactionID === "" || empty(paymentTransaction.custom.requestToken)) {
						//auth again.
						skipOrder = true;
						return skipOrder;
						break;
					}

				}
			} catch (e) {
				return skipOrder;

			}

		}
	}

	return skipOrder;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function multiShiptoExport(multiShip: Boolean) {
	if (multiShip) { //multi shipment order
		var shipnum: Number = 0;
		for each(var shipment: Shipment in currentOrder.getShipments()) {
			shipnum++;
			//for (var ms : Number=1;ms<=currentOrder.getShipments().length;ms++) {
			Logger.debug("Exporting OrderNo / ShipmentNo: " + currentOrder.getOrderNo() + " Shipment: " + shipment.getShipmentNo());

			// Add the <Order> node
			xmlWriter.writeStartElement("Order");

			// Order Header 
			Logger.debug("...writing order header");
			if (!addOrderHeader(this, xmlWriter, currentOrder, shipment, shipnum)) {
				failedOrders.push(currentOrder.getOrderNo());
				addXMLElement(xmlWriter, "OrderHasError", "True");
				xmlWriter.writeEndElement(); // Order
				continue;
			}

			// Order Line Items
			Logger.debug("...writing line items");
			if (!addOrderLineItems(this, xmlWriter, currentOrder, shipment)) {
				failedOrders.push(currentOrder.getOrderNo());
				addXMLElement(xmlWriter, "OrderHasError", "True");
				xmlWriter.writeEndElement(); // Order
				continue;
			}

			// Payments
			Logger.debug("...writing payments");
			if (!addPayments(this, xmlWriter, currentOrder, sdrToken, shipment)) {
				failedOrders.push(currentOrder.getOrderNo());
				addXMLElement(xmlWriter, "OrderHasError", "True");
				xmlWriter.writeEndElement(); // Order
				continue;
			}

			// Shipments
			Logger.debug("...writing shipments");
			if (!addShipment(this, xmlWriter, currentOrder, shipment)) {
				failedOrders.push(currentOrder.getOrderNo());
				addXMLElement(xmlWriter, "OrderHasError", "True");
				xmlWriter.writeEndElement(); // Order
				continue;
			}

			// Billing
			Logger.debug("...writing billing");
			if (!addBilling(this, xmlWriter, currentOrder)) {
				failedOrders.push(currentOrder.getOrderNo());
				addXMLElement(xmlWriter, "OrderHasError", "True");
				xmlWriter.writeEndElement(); // Order
				continue;
			}

			xmlWriter.writeEndElement(); // Order

			Logger.debug("...pushing successful order Shipments");
			successfulOrders.push(currentOrder.getOrderNo());
		}

	} else { //Single Shipment order	

	}

}